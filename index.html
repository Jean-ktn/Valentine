<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Our Universe</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Sarabun:wght@300;500&display=swap" rel="stylesheet" />

  <style>
    body, html {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      overflow: hidden;
      background-color: #000;
      font-family: 'Sarabun', sans-serif;
    }

    #webgl {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 1;
      outline: none;
    }

    #ui-layer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 10;
      pointer-events: none;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #light-burst {
      position: fixed;
      top: 50%; left: 50%;
      width: 0; height: 0;
      background: radial-gradient(circle, #fff 0%, rgba(255,255,255,0.8) 30%, transparent 70%);
      transform: translate(-50%, -50%);
      border-radius: 50%;
      opacity: 0;
      z-index: 5;
      pointer-events: none;
    }

    #start-instruction {
      position: absolute;
      bottom: 15%;
      left: 50%;
      transform: translateX(-50%);
      width: 90%;
      max-width: 600px;
      text-align: center;
      color: rgba(255,255,255,0.9);
      text-shadow: 0 0 20px rgba(255,200,100,0.8);
      font-size: clamp(1rem, 3.5vw, 1.3rem);
      animation: pulseText 2s infinite;
      z-index: 20;
      pointer-events: auto;
      padding: 0 10px;
      box-sizing: border-box;
    }
    @keyframes pulseText { 0%, 100% { opacity: 0.6; } 50% { opacity: 1; } }

    /* Responsive gallery */
    #gallery-container {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%) scale(0.98);
      width: min(86vw, 320px);
      height: min(70vh, 420px);
      opacity: 0;
      visibility: hidden;
      z-index: 30;
      pointer-events: auto;
    }

    .photo-card {
      width: 100%; height: 100%;
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(15px);
      border-radius: 25px;
      border: 2px solid rgba(255,255,255,0.4);
      padding: 20px;
      box-shadow: 0 0 80px rgba(255,160,0,0.5);
      display: flex; flex-direction: column; align-items: center;
      box-sizing: border-box;
    }

    .photo-frame {
      width: 100%; height: 75%;
      border-radius: 20px;
      overflow: hidden;
      position: relative;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }

    .photo-slide {
      width: 100%; height: 100%;
      object-fit: cover;
      position: absolute;
      top: 0; left: 0;
      opacity: 0; transition: opacity 1.2s;
    }
    .photo-slide.active { opacity: 1; }
    
    .video-slide {
      object-fit: cover;
    }

    .love-text {
      margin-top: 20px;
      color: #fff;
      text-align: center;
    }
    .love-text h2 {
      font-family: 'Dancing Script', cursive;
      font-size: clamp(1.8rem, 5vw, 2.2rem); 
      margin: 0;
      color: #ffe680;
      text-shadow: 0 0 20px rgba(255,230,128,0.6);
    }
    .love-text p {
      font-size: clamp(0.9rem, 2.5vw, 1rem);
      margin: 8px 0 0;
      text-shadow: 0 2px 10px rgba(0,0,0,0.5);
    }

    /* Mobile optimizations */
    @media (max-width: 480px) {
      #gallery-container {
        width: min(92vw, 320px);
        height: min(65vh, 400px);
      }
      
      .photo-card {
        padding: 15px;
      }
    }
  </style>
</head>

<body>
  <canvas id="webgl"></canvas>

  <div id="light-burst"></div>

  <div id="ui-layer">
    <div id="start-instruction">✨ Click to see ✨</div>

    <div id="gallery-container">
      <div class="photo-card">
        <div class="photo-frame">
          <img src="photo1.jpg" class="photo-slide active" alt="Love Letter" />
          <img src="photo2.jpg" class="photo-slide" alt="Beautiful Flowers" />
          <video class="photo-slide video-slide" muted loop playsinline preload="auto">
            <source src="video1.mp4" type="video/mp4">
          </video>
        </div>
        <div class="love-text">
          <h2>My Sunshine ✨</h2>
          <p>My World is brighter when I'm with you</p>
        </div>
      </div>
    </div>

  </div>

  <script>
    // Prevent error messages from showing in console
    window.addEventListener('error', function(e) {
      e.preventDefault();
      return true;
    });

    /***********************
     * THREE.JS SCENE
     ***********************/
    const canvas = document.querySelector('canvas#webgl');
    const scene = new THREE.Scene();

    // === GALAXY ===
    const parameters = {
      count: 50000,
      size: 0.012,
      radius: 5,
      branches: 3,
      spin: 1,
      randomness: 0.2,
      randomnessPower: 3,
      insideColor: '#ff6030',
      outsideColor: '#1b3984'
    };

    let geometry = null;
    let material = null;
    let points = null;

    const generateGalaxy = () => {
      if(points !== null) {
        geometry.dispose();
        material.dispose();
        scene.remove(points);
      }

      geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(parameters.count * 3);
      const colors = new Float32Array(parameters.count * 3);

      const colorInside = new THREE.Color(parameters.insideColor);
      const colorOutside = new THREE.Color(parameters.outsideColor);

      for(let i = 0; i < parameters.count; i++) {
        const i3 = i * 3;
        const radius = Math.random() * parameters.radius;
        const spinAngle = radius * parameters.spin;
        const branchAngle = (i % parameters.branches) / parameters.branches * Math.PI * 2;

        const randomX = Math.pow(Math.random(), parameters.randomnessPower) * (Math.random() < 0.5 ? 1 : -1);
        const randomY = Math.pow(Math.random(), parameters.randomnessPower) * (Math.random() < 0.5 ? 1 : -1);
        const randomZ = Math.pow(Math.random(), parameters.randomnessPower) * (Math.random() < 0.5 ? 1 : -1);

        positions[i3    ] = Math.cos(branchAngle + spinAngle) * radius + randomX;
        positions[i3 + 1] = randomY;
        positions[i3 + 2] = Math.sin(branchAngle + spinAngle) * radius + randomZ;

        const mixedColor = colorInside.clone();
        mixedColor.lerp(colorOutside, radius / parameters.radius);

        colors[i3    ] = mixedColor.r;
        colors[i3 + 1] = mixedColor.g;
        colors[i3 + 2] = mixedColor.b;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      material = new THREE.PointsMaterial({
        size: parameters.size,
        sizeAttenuation: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        vertexColors: true
      });

      points = new THREE.Points(geometry, material);
      scene.add(points);
    }
    generateGalaxy();

    // === LIGHTING ===
    const ambientLight = new THREE.AmbientLight(0x1a1a2e, 0.3);
    scene.add(ambientLight);

    // === 3D SUN ===
    const sunGroup = new THREE.Group();
    const sunGeometry = new THREE.SphereGeometry(1, 128, 128);

    const sunMaterial = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        colorCore: { value: new THREE.Color(0xffffff) },
        colorSurface: { value: new THREE.Color(0xffaa00) },
        colorEdge: { value: new THREE.Color(0xff6600) }
      },
      vertexShader: `
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec2 vUv;
        uniform float time;

        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

        float snoise(vec3 v) {
          const vec2 C = vec2(1.0/6.0, 1.0/3.0);
          const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
          vec3 i  = floor(v + dot(v, C.yyy));
          vec3 x0 = v - i + dot(i, C.xxx);
          vec3 g = step(x0.yzx, x0.xyz);
          vec3 l = 1.0 - g;
          vec3 i1 = min(g.xyz, l.zxy);
          vec3 i2 = max(g.xyz, l.zxy);
          vec3 x1 = x0 - i1 + C.xxx;
          vec3 x2 = x0 - i2 + C.yyy;
          vec3 x3 = x0 - D.yyy;
          i = mod289(i);
          vec4 p = permute(permute(permute(
              i.z + vec4(0.0, i1.z, i2.z, 1.0))
              + i.y + vec4(0.0, i1.y, i2.y, 1.0))
              + i.x + vec4(0.0, i1.x, i2.x, 1.0));
          float n_ = 0.142857142857;
          vec3 ns = n_ * D.wyz - D.xzx;
          vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
          vec4 x_ = floor(j * ns.z);
          vec4 y_ = floor(j - 7.0 * x_);
          vec4 x = x_ *ns.x + ns.yyyy;
          vec4 y = y_ *ns.x + ns.yyyy;
          vec4 h = 1.0 - abs(x) - abs(y);
          vec4 b0 = vec4(x.xy, y.xy);
          vec4 b1 = vec4(x.zw, y.zw);
          vec4 s0 = floor(b0)*2.0 + 1.0;
          vec4 s1 = floor(b1)*2.0 + 1.0;
          vec4 sh = -step(h, vec4(0.0));
          vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
          vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
          vec3 p0 = vec3(a0.xy, h.x);
          vec3 p1 = vec3(a0.zw, h.y);
          vec3 p2 = vec3(a1.xy, h.z);
          vec3 p3 = vec3(a1.zw, h.w);
          vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
          p0 *= norm.x;
          p1 *= norm.y;
          p2 *= norm.z;
          p3 *= norm.w;
          vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
          m = m * m;
          return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
        }

        void main() {
          vNormal = normalize(normalMatrix * normal);
          vUv = uv;
          vec3 pos = position;
          float noise = snoise(pos * 2.0 + time * 0.5);
          noise += snoise(pos * 4.0 + time * 0.3) * 0.5;
          pos += normal * noise * 0.05;
          vPosition = pos;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `,
      fragmentShader: `
        uniform float time;
        uniform vec3 colorCore;
        uniform vec3 colorSurface;
        uniform vec3 colorEdge;
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec2 vUv;

        void main() {
          vec3 viewDirection = normalize(cameraPosition - vPosition);
          float fresnel = pow(1.0 - dot(viewDirection, vNormal), 3.0);
          float pattern = sin(vUv.x * 20.0 + time) * cos(vUv.y * 20.0 + time) * 0.5 + 0.5;
          pattern += sin(vUv.x * 10.0 - time * 0.5) * 0.3;
          vec3 color = mix(colorCore, colorSurface, fresnel * 0.7);
          color = mix(color, colorEdge, fresnel);
          color += pattern * 0.2;
          float pulse = sin(time * 2.0) * 0.1 + 0.9;
          color *= pulse;
          gl_FragColor = vec4(color, 1.0);
        }
      `
    });

    const sun = new THREE.Mesh(sunGeometry, sunMaterial);
    sunGroup.add(sun);

    for(let i = 0; i < 5; i++) {
      const scale = 1.2 + i * 0.15;
      const opacity = 0.25 - i * 0.04;
      const coronaGeo = new THREE.SphereGeometry(scale, 64, 64);
      const coronaMat = new THREE.ShaderMaterial({
        transparent: true,
        side: THREE.BackSide,
        blending: THREE.AdditiveBlending,
        uniforms: {
          time: { value: 0 },
          opacity: { value: opacity },
          color: { value: new THREE.Color(0xffaa00) }
        },
        vertexShader: `
          varying vec3 vNormal;
          void main() {
            vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform float time;
          uniform float opacity;
          uniform vec3 color;
          varying vec3 vNormal;
          void main() {
            float intensity = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
            float flicker = sin(time * 3.0 + gl_FragCoord.x * 0.1) * 0.2 + 0.8;
            gl_FragColor = vec4(color, intensity * opacity * flicker);
          }
        `
      });
      const corona = new THREE.Mesh(coronaGeo, coronaMat);
      sunGroup.add(corona);
    }

    const flareCount = 200;
    const flareGeometry = new THREE.BufferGeometry();
    const flarePositions = new Float32Array(flareCount * 3);

    for(let i = 0; i < flareCount; i++) {
      const radius = 1.5 + Math.random() * 1;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * Math.PI;
      flarePositions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
      flarePositions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
      flarePositions[i * 3 + 2] = radius * Math.cos(phi);
    }

    flareGeometry.setAttribute('position', new THREE.BufferAttribute(flarePositions, 3));
    const flareMaterial = new THREE.PointsMaterial({
      color: 0xffdd00,
      size: 0.05,
      transparent: true,
      opacity: 0.6,
      blending: THREE.AdditiveBlending
    });
    const flares = new THREE.Points(flareGeometry, flareMaterial);
    sunGroup.add(flares);

    const sunLight = new THREE.PointLight(0xffd700, 3, 20);
    sunGroup.add(sunLight);
    sunGroup.position.set(-3, 1.5, 2);
    scene.add(sunGroup);

    // === 3D MOON ===
    const moonGroup = new THREE.Group();
    const moonGeometry = new THREE.SphereGeometry(0.8, 128, 128);

    const moonMaterial = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        sunPosition: { value: sunGroup.position }
      },
      vertexShader: `
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec2 vUv;
        uniform float time;

        float hash(vec2 p) {
          return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
        }

        float noise(vec2 p) {
          vec2 i = floor(p);
          vec2 f = fract(p);
          f = f * f * (3.0 - 2.0 * f);
          float a = hash(i);
          float b = hash(i + vec2(1.0, 0.0));
          float c = hash(i + vec2(0.0, 1.0));
          float d = hash(i + vec2(1.0, 1.0));
          return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
        }

        void main() {
          vNormal = normalize(normalMatrix * normal);
          vUv = uv;
          vec3 pos = position;
          float craters = noise(uv * 20.0) * 0.5;
          craters += noise(uv * 40.0) * 0.25;
          craters += noise(uv * 80.0) * 0.125;
          pos += normal * craters * 0.03;
          vPosition = pos;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `,
      fragmentShader: `
        uniform float time;
        uniform vec3 sunPosition;
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec2 vUv;

        float hash(vec2 p) {
          return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
        }

        float noise(vec2 p) {
          vec2 i = floor(p);
          vec2 f = fract(p);
          f = f * f * (3.0 - 2.0 * f);
          float a = hash(i);
          float b = hash(i + vec2(1.0, 0.0));
          float c = hash(i + vec2(0.0, 1.0));
          float d = hash(i + vec2(1.0, 1.0));
          return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
        }

        void main() {
          float surface = noise(vUv * 10.0);
          vec3 baseColor = vec3(0.7, 0.7, 0.7);
          vec3 darkColor = vec3(0.4, 0.4, 0.4);
          vec3 color = mix(darkColor, baseColor, surface);

          float craterPattern = noise(vUv * 30.0);
          color *= 0.8 + craterPattern * 0.4;

          vec3 lightDir = normalize(sunPosition - vPosition);
          float diff = max(dot(vNormal, lightDir), 0.0);

          vec3 viewDir = normalize(cameraPosition - vPosition);
          float rim = 1.0 - max(dot(viewDir, vNormal), 0.0);
          rim = pow(rim, 3.0);

          color *= (diff * 0.7 + 0.3);
          color += rim * vec3(0.3, 0.4, 0.6) * 0.3;
          gl_FragColor = vec4(color, 1.0);
        }
      `
    });

    const moon = new THREE.Mesh(moonGeometry, moonMaterial);
    moonGroup.add(moon);

    const moonAtmosphereGeo = new THREE.SphereGeometry(0.95, 64, 64);
    const moonAtmosphereMat = new THREE.ShaderMaterial({
      transparent: true,
      side: THREE.BackSide,
      blending: THREE.AdditiveBlending,
      uniforms: { time: { value: 0 } },
      vertexShader: `
        varying vec3 vNormal;
        void main() {
          vNormal = normalize(normalMatrix * normal);
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float time;
        varying vec3 vNormal;
        void main() {
          float intensity = pow(0.6 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
          vec3 atmosphereColor = vec3(0.5, 0.6, 0.9);
          float pulse = sin(time * 0.5) * 0.2 + 0.8;
          gl_FragColor = vec4(atmosphereColor, intensity * 0.4 * pulse);
        }
      `
    });

    const moonAtmosphere = new THREE.Mesh(moonAtmosphereGeo, moonAtmosphereMat);
    moonGroup.add(moonAtmosphere);

    const moonLight = new THREE.PointLight(0x8ca6db, 1.5, 12);
    moonGroup.add(moonLight);
    moonGroup.position.set(3, -1.5, 2);
    scene.add(moonGroup);

    // === CAMERA & RENDERER ===
    const sizes = { width: window.innerWidth, height: window.innerHeight };
    const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 0.1, 100);
    camera.position.set(0, 1, 6);
    scene.add(camera);

    const renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });
    renderer.setSize(sizes.width, sizes.height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    window.addEventListener('resize', () => {
      sizes.width = window.innerWidth;
      sizes.height = window.innerHeight;
      camera.aspect = sizes.width / sizes.height;
      camera.updateProjectionMatrix();
      renderer.setSize(sizes.width, sizes.height);
    });

    let mouseX = 0;
    let mouseY = 0;

    // Better on mobile too
    window.addEventListener('pointermove', (event) => {
      mouseX = event.clientX / sizes.width - 0.5;
      mouseY = event.clientY / sizes.height - 0.5;
    }, { passive: true });

    // === ANIMATION LOOP ===
    const clock = new THREE.Clock();
    const tick = () => {
      const elapsedTime = clock.getElapsedTime();

      if (points) points.rotation.y = elapsedTime * 0.05;

      if(sunGroup) {
        sunGroup.rotation.y = elapsedTime * 0.1;
        sunGroup.children.forEach(child => {
          if(child.material && child.material.uniforms && child.material.uniforms.time) {
            child.material.uniforms.time.value = elapsedTime;
          }
        });
        const flarePts = sunGroup.children.find(c => c.type === 'Points');
        if(flarePts) {
          flarePts.rotation.y = elapsedTime * 0.5;
          flarePts.rotation.z = elapsedTime * 0.3;
        }
      }

      if(moonGroup) {
        moonGroup.rotation.y = elapsedTime * 0.05;
        moonGroup.children.forEach(child => {
          if(child.material && child.material.uniforms && child.material.uniforms.time) {
            child.material.uniforms.time.value = elapsedTime;
          }
        });
      }

      camera.position.x += (mouseX * 3 - camera.position.x) * 0.05;
      camera.position.y += (-mouseY * 2 + 1 - camera.position.y) * 0.05;
      camera.lookAt(0, 0.5, 0);

      renderer.render(scene, camera);
      window.requestAnimationFrame(tick);
    }
    tick();

    /***********************
     * UI INTERACTION
     ***********************/
    let step = 0;
    const lightBurst = document.getElementById('light-burst');
    const gallery = document.getElementById('gallery-container');
    const instruction = document.getElementById('start-instruction');

    let slideshowCount = 0;

    document.body.addEventListener('click', () => {
      if (step === 0) {
        step = 1;

        const tl = gsap.timeline();

        tl.to(instruction, { 
            opacity: 0, 
            duration: 0.5,
            onComplete: () => {
              instruction.style.visibility = 'hidden';
            }
          })
          .to(sunGroup.position,  { x: 0, y: 0, z: 1, duration: 2, ease: "power2.inOut" }, "merge")
          .to(moonGroup.position, { x: 0, y: 0, z: 1, duration: 2, ease: "power2.inOut" }, "merge")
          .to(lightBurst, {
            width: '150vmax',
            height: '150vmax',
            opacity: 0.9,
            duration: 0.3,
            ease: "power2.out"
          }, "-=0.3")
          .to(lightBurst, {
            opacity: 0,
            duration: 0.5,
            ease: "power2.in"
          })
          .to(canvas, { opacity: 0.85, duration: 0.8 }, "-=0.5")
          .to(sunGroup.scale,  { x: 0, y: 0, z: 0, duration: 0.4 }, "-=0.8")
          .to(moonGroup.scale, { x: 0, y: 0, z: 0, duration: 0.4 }, "-=0.8")
          .to(gallery, { autoAlpha: 1, scale: 1, duration: 1, ease: "back.out(1.3)" }, "-=0.3");

        startSlideshow();
      }
    });

    function startSlideshow() {
      const slides = document.querySelectorAll('.photo-slide');
      let index = 0;

      setInterval(() => {
        slides[index].classList.remove('active');
        
        // Pause video if leaving it
        if (slides[index].tagName === 'VIDEO') {
          slides[index].pause();
          slides[index].currentTime = 0;
        }
        
        index = (index + 1) % slides.length;
        slides[index].classList.add('active');
        
        // Play video if entering it
        if (slides[index].tagName === 'VIDEO') {
          slides[index].play();
        }

        slideshowCount++;
      }, 3000);
    }
  </script>
</body>
</html>